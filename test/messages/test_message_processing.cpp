#include <array>
#include <cstdint>
#include <future>
#include <thread>
#include <utility>
#include <vector>

#include <boost/asio/co_spawn.hpp>
#include <boost/asio/detached.hpp>
#include <boost/asio/io_context.hpp>
#include <boost/test/unit_test.hpp>

#include "errors/protocol_error_codes.h"
#include "messages/jandy/jandy_message_constants.h"
#include "messages/jandy/jandy_message_generator.h"
#include "messages/jandy/messages/jandy_message_ack.h"

#include "utilities/unit_test_ostream_support.h"

using TestData = std::array<uint8_t, 16>;
using TestVector = std::pair<TestData, uint8_t>;
using TestVectorCollection = std::vector<TestVector>;

using namespace AqualinkAutomate;
using namespace AqualinkAutomate::ErrorCodes;
using namespace AqualinkAutomate::ErrorCodes::Protocol;
using namespace AqualinkAutomate::Messages;
using namespace AqualinkAutomate::Messages::Jandy;

BOOST_AUTO_TEST_SUITE(MessageProcessing);

BOOST_AUTO_TEST_CASE(InvalidPacketData)
{
	TestVectorCollection test_vectors;
	test_vectors.push_back(std::make_pair<TestData>({ '1','2','3','4','5','6','7','8','9','0','a','b','c','d','e','f' }, 16));
	test_vectors.push_back(std::make_pair<TestData>({ 'f','e','d','c','b','a','0','9','8','7','6','5','4','3','2','1' }, 16));

	JandyMessageGenerator jandy_message_generator;

	for (auto [tv, len] : test_vectors)
	{
		//BOOST_TEST(false == jandy_message_generator.GenerateMessageFromRawData(tv, len).has_value());
	}
}

BOOST_AUTO_TEST_CASE(PacketHasHeaderButNoEnd)
{
	TestVectorCollection test_vectors;
	test_vectors.push_back(std::make_pair<TestData>(
		{
			static_cast<uint8_t>(HEADER_BYTE_DLE),
			static_cast<uint8_t>(HEADER_BYTE_STX),
			'3','4','5','6','7','8','9','0','a','b','c','d','e','f'
		},
		16));

	test_vectors.push_back(std::make_pair<TestData>({ 'f','e','d','c','b','a','0','9','8','7','6','5','4','3','2','1' }, 16));

	JandyMessageGenerator jandy_message_generator;

	for (auto [tv, len] : test_vectors)
	{
		//BOOST_TEST(false == jandy_message_generator.GenerateMessageFromRawData(tv, len).has_value());
	}
}

BOOST_AUTO_TEST_CASE(PacketIsTooLong)
{
}

BOOST_AUTO_TEST_CASE(ValidPackets_50)
{
	using namespace AqualinkAutomate;
	using namespace AqualinkAutomate::ErrorCodes;
	using namespace AqualinkAutomate::Messages;
	using namespace AqualinkAutomate::Messages::Jandy::Messages;


	std::array<uint8_t, 496> test_data = 
	{ 
		0x10, 0x02, 0x40, 0x02, 0x00, 0x00, 0x00, 0x40, 0x04, 0x98, 0x10, 0x03, 0x10, 0x02, 0x00, 0x01,
		0x80, 0x00, 0x93, 0x10, 0x03, 0x10, 0x02, 0x80, 0x00, 0x92, 0x10, 0x03, 0x10, 0x02, 0x10, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x10, 0x03, 0x00, 0x10, 0x02, 0x00, 0x01, 0x00, 0x00,
		0x13, 0x10, 0x03, 0x10, 0x02, 0x33, 0x30, 0x75, 0x10, 0x03, 0x00, 0x00, 0x10, 0x02, 0x00, 0x01,
		0x00, 0x00, 0x13, 0x10, 0x03, 0x10, 0x02, 0xa3, 0x53, 0x08, 0x10, 0x03, 0x00, 0x00, 0x10, 0x02,
		0x00, 0x01, 0x3f, 0x00, 0x52, 0x10, 0x03, 0x10, 0x02, 0x50, 0x11, 0x0a, 0x7d, 0x10, 0x03, 0x00,
		0x10, 0x02, 0x00, 0x16, 0x28, 0x00, 0x00, 0x00, 0x50, 0x10, 0x03, 0x10, 0x02, 0x60, 0x00, 0x72,
		0x10, 0x03, 0x10, 0x02, 0x40, 0x02, 0x00, 0x00, 0x00, 0x40, 0x04, 0x98, 0x10, 0x03, 0x10, 0x02,
		0x00, 0x01, 0x80, 0x00, 0x93, 0x10, 0x03, 0x10, 0x02, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x24, 0x10, 0x03, 0x00, 0x10, 0x02, 0x00, 0x01, 0x00, 0x00, 0x13, 0x10, 0x03, 0x10, 0x02,
		0x33, 0x30, 0x75, 0x10, 0x03, 0x00, 0x00, 0x10, 0x02, 0x00, 0x01, 0x00, 0x00, 0x13, 0x10, 0x03,
		0x10, 0x02, 0xa3, 0x53, 0x08, 0x10, 0x03, 0x00, 0x00, 0x10, 0x02, 0x00, 0x01, 0x3f, 0x00, 0x52,
		0x10, 0x03, 0x10, 0x02, 0x50, 0x11, 0x0a, 0x7d, 0x10, 0x03, 0x00, 0x10, 0x02, 0x00, 0x16, 0x28,
		0x00, 0x00, 0x00, 0x50, 0x10, 0x03, 0x10, 0x02, 0x30, 0x00, 0x42, 0x10, 0x03, 0x10, 0x02, 0x40,
		0x02, 0x00, 0x00, 0x00, 0x40, 0x04, 0x98, 0x10, 0x03, 0x10, 0x02, 0x00, 0x01, 0x80, 0x00, 0x93,
		0x10, 0x03, 0x10, 0x02, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x10, 0x03, 0x00,
		0x10, 0x02, 0x00, 0x01, 0x00, 0x00, 0x13, 0x10, 0x03, 0x10, 0x02, 0x33, 0x30, 0x75, 0x10, 0x03,
		0x00, 0x00, 0x10, 0x02, 0x00, 0x01, 0x00, 0x00, 0x13, 0x10, 0x03, 0x10, 0x02, 0xa3, 0x53, 0x08,
		0x10, 0x03, 0x00, 0x00, 0x10, 0x02, 0x00, 0x01, 0x3f, 0x00, 0x52, 0x10, 0x03, 0x10, 0x02, 0x50,
		0x11, 0x0a, 0x7d, 0x10, 0x03, 0x00, 0x10, 0x02, 0x00, 0x16, 0x28, 0x00, 0x00, 0x00, 0x50, 0x10,
		0x03, 0x10, 0x02, 0x60, 0x00, 0x72, 0x10, 0x03, 0x10, 0x02, 0x40, 0x02, 0x00, 0x00, 0x00, 0x40,
		0x04, 0x98, 0x10, 0x03, 0x10, 0x02, 0x00, 0x01, 0x80, 0x00, 0x93, 0x10, 0x03, 0x10, 0x02, 0x10,
		0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x10, 0x03, 0x00, 0x10, 0x02, 0x00, 0x01, 0x00,
		0x00, 0x13, 0x10, 0x03, 0x10, 0x02, 0x33, 0x30, 0x75, 0x10, 0x03, 0x00, 0x00, 0x10, 0x02, 0x00,
		0x01, 0x00, 0x00, 0x13, 0x10, 0x03, 0x10, 0x02, 0xa3, 0x53, 0x08, 0x10, 0x03, 0x00, 0x00, 0x10,
		0x02, 0x00, 0x01, 0x3f, 0x00, 0x52, 0x10, 0x03, 0x10, 0x02, 0x50, 0x11, 0x0a, 0x7d, 0x10, 0x03,
		0x00, 0x10, 0x02, 0x00, 0x16, 0x28, 0x00, 0x00, 0x00, 0x50, 0x10, 0x03, 0x10, 0x02, 0x31, 0x00,
		0x43, 0x10, 0x03, 0x10, 0x02, 0x40, 0x02, 0x00, 0x00, 0x00, 0x40, 0x04, 0x98, 0x10, 0x03, 0x10,
		0x02, 0x00, 0x01, 0x80, 0x00, 0x93, 0x10, 0x03, 0x10, 0x02, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x24, 0x10, 0x03, 0x00, 0x10, 0x02, 0x00, 0x01, 0x00, 0x00, 0x13, 0x10, 0x03, 0x10,
		0x02, 0x81, 0x00, 0x93, 0x10, 0x03, 0xDE, 0xAD, 0xBE, 0xEF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
	};

	JandyMessageGenerator jandy_message_generator;
	boost::asio::io_context io_context;

	auto run_test = [&](auto& result_checker, auto& test_data) -> void
	{
		boost::asio::co_spawn(io_context, [&]() -> boost::asio::awaitable<void>
			{
				jandy_message_generator.InjectRawSerialData(test_data);
				result_checker(co_await jandy_message_generator.GenerateMessageFromRawData());
			},
			boost::asio::detached);

		io_context.poll();
	};

	const auto test_data_01 = std::span(test_data).subspan(0, 16);
	const auto test_data_02 = std::span(test_data).subspan(16, 16);
	const auto test_data_03 = std::span(test_data).subspan(32, 16);
	const auto test_data_04 = std::span(test_data).subspan(48, 16);
	const auto test_data_05 = std::span(test_data).subspan(64, 16);
	const auto test_data_06 = std::span(test_data).subspan(80, 16);
	const auto test_data_07 = std::span(test_data).subspan(96, 16);
	const auto test_data_08 = std::span(test_data).subspan(112, 16);
	const auto test_data_09 = std::span(test_data).subspan(128, 16);
	const auto test_data_10 = std::span(test_data).subspan(144, 16);
	const auto test_data_11 = std::span(test_data).subspan(160, 16);
	const auto test_data_12 = std::span(test_data).subspan(176, 16);
	const auto test_data_13 = std::span(test_data).subspan(192, 16);
	const auto test_data_14 = std::span(test_data).subspan(208, 16);
	const auto test_data_15 = std::span(test_data).subspan(224, 16);
	const auto test_data_16 = std::span(test_data).subspan(240, 16);
	const auto test_data_17 = std::span(test_data).subspan(256, 16);
	const auto test_data_18 = std::span(test_data).subspan(272, 16);
	const auto test_data_19 = std::span(test_data).subspan(288, 16);
	const auto test_data_20 = std::span(test_data).subspan(304, 16);
	const auto test_data_21 = std::span(test_data).subspan(320, 16);
	const auto test_data_22 = std::span(test_data).subspan(336, 16);
	const auto test_data_23 = std::span(test_data).subspan(352, 16);
	const auto test_data_24 = std::span(test_data).subspan(368, 16);
	const auto test_data_25 = std::span(test_data).subspan(384, 16);
	const auto test_data_26 = std::span(test_data).subspan(400, 16);
	const auto test_data_27 = std::span(test_data).subspan(416, 16);
	const auto test_data_28 = std::span(test_data).subspan(432, 16);
	const auto test_data_29 = std::span(test_data).subspan(448, 16);
	const auto test_data_30 = std::span(test_data).subspan(464, 16);
	const auto test_data_31 = std::span(test_data).subspan(480, 16);

	const auto test_iteration_01 = [](const auto& result) -> void 
	{
		BOOST_TEST(result.has_value());

		if ((result.has_value()) && (nullptr != result.value()))
		{
			auto message_ptr = result.value();
			BOOST_TEST(Jandy::Messages::JandyAckMessage() == *message_ptr);
		}
	};

	run_test(test_iteration_01, test_data_01);
	run_test(test_iteration_01, test_data_02);
	run_test(test_iteration_01, test_data_03);
	run_test(test_iteration_01, test_data_04);
	run_test(test_iteration_01, test_data_05);
	run_test(test_iteration_01, test_data_06);
	run_test(test_iteration_01, test_data_07);
	run_test(test_iteration_01, test_data_08);
	run_test(test_iteration_01, test_data_09);
	run_test(test_iteration_01, test_data_10);
	run_test(test_iteration_01, test_data_11);
	run_test(test_iteration_01, test_data_12);
	run_test(test_iteration_01, test_data_13);
	run_test(test_iteration_01, test_data_14);
	run_test(test_iteration_01, test_data_15);
}

BOOST_AUTO_TEST_SUITE_END();

